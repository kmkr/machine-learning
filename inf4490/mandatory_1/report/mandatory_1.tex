\documentclass{article}

\usepackage{booktabs}
\usepackage{microtype}
\title{Mandatory Assignment 1}
\author{Kris-Mikael Krister (krismikk)\\\texttt{krismikael@protonmail.com}}
\date{\today}

\begin{document}

\maketitle
\section*{Exhaustive Search}

This section describes the results using an exhaustive search implementation for finding the shortest path of a set of cities, also known as the travelling salesman problem. Since an exhaustive search verifies all possible permutations, the algorithm is guaranteed to find the shortest path. See

From the set of the following ten cities, the path found to be shortest is Copenhagen $\rightarrow$ Hamburg $\rightarrow$ Brussels $\rightarrow$ Dublin $\rightarrow$ Barcelona $\rightarrow$ Belgrade $\rightarrow$ Istanbul $\rightarrow$ Bucharest $\rightarrow$ Budapest $\rightarrow$ Berlin. The total distance for the route is 7486.31 km.\\

\noindent The solution was found using 21.25 seconds on a Linux i5-4670 CPU @ 3.40GHz. A single core was used when running the program, so exploiting the multi-core architecture would be a possible improvement to the program.\\

\begin{center}
\begin{tabular}{crr}
\toprule
Number of cities & Permutations & Execution time (seconds) \\
\midrule
$5$ & $120$ & $0.000349998474121$ \\
$6$ & $720$ & $0.00444889068604$ \\
$7$ & $5\,040$ & $0.0201399326324$ \\
$8$ & $40\,320$ & $0.219367980957$ \\
$9$ & $362\,880$ & $1.87963008881$ \\
$10$ & $3\,628\,800$ & $21.25$ \\
$11$ & $39\,916\,800$ & $258$ \\
$12$ & $479\,001\,600$ & $3406.87$ \\
\bottomrule
\end{tabular}
\end{center}

\noindent Difference in execution time corresponds to the number of permutations. The amount of permutations is factorial ($O(n!)$), so based on the results above, the expected running time for all 24 cities would be approximately $3406.87 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22 * 23 * 24 \approx 4.41 \times 10^{18}$ seconds.

\subsection*{How to run the program}

Execute the \texttt{tsp\_exhaustive.py} file with the amount of cities to check.

\begin{verbatim}
$ python tsp_exhaustive.py 5

Exhastive search using 5 first cities
Found shortest {'distance': 4983.38, 'route': ('Barcelona',
'Belgrade', 'Bucharest', 'Berlin', 'Brussels')} in
time 0.00048303604126
\end{verbatim}

\noindent All modules have one or more unit tests to verify the implementation. To run all tests, use Python's unittest discovery:

\begin{verbatim}
$ python -m unittest discover -p '*_test.py'
\end{verbatim}

\section*{Hill Climber}

This section describes the results using a hill climber implementation to find the shortest path.

\subsection*{Implementation}

Key properties for the implementation are shown below.

\begin{itemize}
    \item A random permutation (route) is chosen as a starting point for the algorithm.
    \item The total route distance for the route is calculated.
    \item The position of two random cities in the route are swapped and the route distance is calculated.
    \item If the new route distance is shorter than the previous one, update the pointer of the best route.
    \item Repeat until the maximum amount of total iterations are reached (set to 5000), or maximum amount of iterations (set to 50) with a change below a threshold (300) is reached.
\end{itemize}

\subsection*{Results}

The algorithm is stochastic and the result can differ between each run. Multiple iterations of the hill climber algorithm must therefore run to be able to compare it to the exhaustive search algorithm. Twenty iterations were used for the comparison.

\begin{center}
\begin{tabular}{lcc}
\toprule
Measurement & Ten first cities & All cities \\
\midrule
Best & $7\,486.31$ & $127\,59.8$ \\
Worst & $8\,407.18$ & $15\,209.07$ \\
Mean & $7\,747.34$ & $14\,005.63$ \\
Standard deviation & $346.35$ & $821.67$ \\
\bottomrule
\end{tabular}
\end{center}

The hill climber found the optimal solution for the case of the ten first cities (the optimal solution was found with the exhaustive search). The optimal solution for all cities is unknown.

\subsection*{How to run the program}

Execute the \texttt{tsp\_hill\_climber.py} file with the amount of cities to check. Note that Python 3.4 or later is required due to usage of the statistics library for standard deviation.

\begin{verbatim}
$ python tsp_hill_climber.py 24

Hill climber search using first 24 cities. Running in total 20
iterations.
Best   12759.8
Worst  15209.069999999998
Mean   14005.635999999999
stdev  821.6690607307211
\end{verbatim}


\section*{Genetic Algorithm}

This section describes the results using a genetic algorithm for finding the shortest path. This is a permutation problem, so the crossover and mutation operators must be chosen accordingly. The phenotype space is the set of city names. The crossover algorithm used is partial mapped crossover that supports array of city names as input, so the genotype is the same as the phenotype.

\subsection*{Implementation}

The genetic algorithm runs in total three rounds, each time with a different population size. Number of iterations for each round is set to 20. The individuals in the population are all \textit{routes}, e.g. Berlin $\rightarrow$ Barcelona $\rightarrow$ $\ldots$ $\rightarrow$ Belgrade. Each individual is a permutation of the  has the same number of cities (genes).
The general steps for the implementation are shown below.

\begin{enumerate}
    \item An initial population is randomly generated.
    \item The fitness for each individual is calculated. The fitness is based on the total route distance for the individual, compared to the total route distance for the entire population. The shortest route has the highest fitness.
    \item The number of parents is half the population size, and parents are chosen using a stochastic universal sampling (SUS) method to avoid selection bias.
    \item Offspring is created using a partial mapped crossover algorithm. The number of offspring is double the amount of the population.
    \item A $\mu,\lambda$ selection is used to form the next generation. All parents are discarded, and the fittest half of the $2 \times \lambda$ offspring are selected for the next generation.
\end{enumerate}

\subsubsection*{Number of generations}

Skriv noe om at det konvergerte mot en løsning og at antall generasjoner ikke trengte å være så høy.

\subsection*{Results}

Population size 50

\begin{center}
\begin{tabular}{lcc}
\toprule
Measurement & Ten first cities & All cities \\
\midrule
Best & $7\,486.31$ & $12\,340.50$ \\
Worst & $7\,503.10$ & $15\,394.07$ \\
Mean & $7\,489.67$ & $14\,064.51$ \\
Standard deviation & $3.38$ & $819.11$ \\
\bottomrule
\end{tabular}
\end{center}

Population size 100

\begin{center}
\begin{tabular}{lcc}
\toprule
Measurement & Ten first cities & All cities \\
\midrule
Best & $7\,486.31$ & $12\,493.47$ \\
Worst & $7\,486.31$ & $15\,850.64$ \\
Mean & $7\,486.31$ & $13\,657.37$ \\
Standard deviation & $6.10$ & $887.05$ \\
\bottomrule
\end{tabular}
\end{center}

Population size 200

\begin{center}
\begin{tabular}{lcc}
\toprule
Measurement & Ten first cities & All cities \\
\midrule
Best & $7\,486.31$ & $12\,334.35$ \\
Worst & $7\,486.31$ & $14\,680.17$ \\
Mean & $7\,486.31$ & $13\,319.50$ \\
Standard deviation & $\approx 0$ & $621.72$ \\
\bottomrule
\end{tabular}
\end{center}

Noter noe om at alle 10-city med pop 100+ fant den riktige verdien

\end{document}
